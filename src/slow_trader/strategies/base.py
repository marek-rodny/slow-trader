"""Base class for trading strategies."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any
import pandas as pd


class Signal(Enum):
    """Trading signal types."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"


@dataclass
class TradeSignal:
    """A trading signal generated by a strategy."""
    signal: Signal
    symbol: str
    strategy: str
    strength: float = 0.0  # 0-1, how confident the signal is
    price: float = 0.0
    stop_loss: float | None = None
    take_profit: float | None = None
    reason: str = ""
    indicators: dict = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.now)

    def is_actionable(self) -> bool:
        """Check if signal requires action."""
        return self.signal in (Signal.BUY, Signal.SELL, Signal.CLOSE_LONG, Signal.CLOSE_SHORT)


class Strategy(ABC):
    """Abstract base class for trading strategies."""

    def __init__(self, name: str, params: dict | None = None):
        """
        Initialize strategy.

        Args:
            name: Strategy name
            params: Strategy parameters
        """
        self.name = name
        self.params = params or {}
        self.min_periods = self._calculate_min_periods()

    @abstractmethod
    def analyze(self, data: pd.DataFrame, symbol: str) -> TradeSignal:
        """
        Analyze market data and generate a trading signal.

        Args:
            data: DataFrame with OHLCV data
            symbol: Trading pair symbol

        Returns:
            TradeSignal with the recommendation
        """
        pass

    @abstractmethod
    def _calculate_min_periods(self) -> int:
        """Calculate minimum periods needed for this strategy."""
        pass

    def validate_data(self, data: pd.DataFrame) -> bool:
        """
        Validate that data meets strategy requirements.

        Args:
            data: DataFrame to validate

        Returns:
            True if valid
        """
        if data is None or len(data) < self.min_periods:
            return False

        required_columns = ["open", "high", "low", "close", "volume"]
        return all(col in data.columns for col in required_columns)

    def get_params(self) -> dict:
        """Get strategy parameters."""
        return self.params.copy()

    def set_params(self, params: dict) -> None:
        """Set strategy parameters."""
        self.params.update(params)
        self.min_periods = self._calculate_min_periods()

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(name='{self.name}', params={self.params})"


class StrategyManager:
    """Manages multiple strategies and aggregates signals."""

    def __init__(self):
        self.strategies: dict[str, Strategy] = {}
        self.weights: dict[str, float] = {}

    def add_strategy(self, strategy: Strategy, weight: float = 1.0) -> None:
        """
        Add a strategy to the manager.

        Args:
            strategy: Strategy instance
            weight: Weight for this strategy in signal aggregation
        """
        self.strategies[strategy.name] = strategy
        self.weights[strategy.name] = weight

    def remove_strategy(self, name: str) -> None:
        """Remove a strategy by name."""
        if name in self.strategies:
            del self.strategies[name]
            del self.weights[name]

    def get_signals(self, data: pd.DataFrame, symbol: str) -> list[TradeSignal]:
        """
        Get signals from all strategies.

        Args:
            data: DataFrame with OHLCV data
            symbol: Trading pair symbol

        Returns:
            List of signals from all strategies
        """
        signals = []
        for strategy in self.strategies.values():
            if strategy.validate_data(data):
                signal = strategy.analyze(data, symbol)
                signals.append(signal)
        return signals

    def get_consensus(self, data: pd.DataFrame, symbol: str) -> TradeSignal:
        """
        Get weighted consensus signal from all strategies.

        Args:
            data: DataFrame with OHLCV data
            symbol: Trading pair symbol

        Returns:
            Aggregated signal based on weighted voting
        """
        signals = self.get_signals(data, symbol)

        if not signals:
            return TradeSignal(
                signal=Signal.HOLD,
                symbol=symbol,
                strategy="consensus",
                reason="No valid signals",
            )

        # Count weighted votes
        buy_score = 0.0
        sell_score = 0.0
        total_weight = 0.0
        indicators = {}

        for sig in signals:
            weight = self.weights.get(sig.strategy, 1.0)
            total_weight += weight

            if sig.signal == Signal.BUY:
                buy_score += weight * sig.strength
            elif sig.signal == Signal.SELL:
                sell_score += weight * sig.strength

            indicators[sig.strategy] = {
                "signal": sig.signal.value,
                "strength": sig.strength,
                "indicators": sig.indicators,
            }

        # Normalize scores
        if total_weight > 0:
            buy_score /= total_weight
            sell_score /= total_weight

        # Determine consensus
        threshold = 0.3  # Minimum score to act

        if buy_score > sell_score and buy_score > threshold:
            return TradeSignal(
                signal=Signal.BUY,
                symbol=symbol,
                strategy="consensus",
                strength=buy_score,
                reason=f"Buy consensus: {buy_score:.2f} vs sell {sell_score:.2f}",
                indicators=indicators,
            )
        elif sell_score > buy_score and sell_score > threshold:
            return TradeSignal(
                signal=Signal.SELL,
                symbol=symbol,
                strategy="consensus",
                strength=sell_score,
                reason=f"Sell consensus: {sell_score:.2f} vs buy {buy_score:.2f}",
                indicators=indicators,
            )
        else:
            return TradeSignal(
                signal=Signal.HOLD,
                symbol=symbol,
                strategy="consensus",
                strength=max(buy_score, sell_score),
                reason=f"No consensus: buy {buy_score:.2f}, sell {sell_score:.2f}",
                indicators=indicators,
            )
